/**
 * @file m5gotchi_field_ops_mode.h
 * @brief Modo operacional para uso profissional em campo
 *
 * Permite alternar entre modo kawaii/tamagotchi e modo operacional profissional,
 * otimizando recursos, bateria e apresenta√ß√£o para pentest em campo.
 *
 * @version 1.0.0
 * @date 2025-10-30
 */

#ifndef M5GOTCHI_FIELD_OPS_MODE_H
#define M5GOTCHI_FIELD_OPS_MODE_H

#include <Preferences.h>
#include <M5Unified.h>

/**
 * @brief Gerenciador de modos operacionais
 *
 * Oferece diferentes perfis de opera√ß√£o:
 * - NEKO_MODE: Modo tamagotchi completo com anima√ß√µes e personalidade
 * - PROFESSIONAL: Modo profissional com interface limpa
 * - STEALTH: Modo furtivo com m√≠nimo de feedback visual/sonoro
 * - BATTERY_SAVER: Otimiza√ß√£o extrema de bateria
 */
class FieldOpsMode {
public:
    /**
     * @brief Modos de opera√ß√£o
     */
    enum Mode {
        NEKO_MODE,          // Modo completo tamagotchi
        PROFESSIONAL,       // Modo profissional
        STEALTH,           // Modo stealth/furtivo
        BATTERY_SAVER,     // Economia de bateria
        CUSTOM             // Configura√ß√£o customizada
    };

    /**
     * @brief Perfil de configura√ß√£o para cada modo
     */
    struct Profile {
        // Visual
        bool animations = true;
        bool particles = true;
        bool nekoReactions = true;
        bool statusIcons = true;
        bool colorTheme = true;
        uint8_t brightness = 128;  // 0-255
        uint8_t screenTimeout = 60; // segundos (0 = nunca)

        // Audio
        bool sounds = true;
        bool music = true;
        bool beeps = true;
        uint8_t volume = 50;       // 0-100

        // Feedback
        bool vibration = true;
        bool ledIndicators = true;
        bool serialOutput = true;
        bool verboseLogging = false;

        // Performance
        uint16_t displayFPS = 30;
        bool reducedAnimations = false;
        bool minimalUI = false;

        // Energia
        bool cpuPowerSave = false;
        bool wifiPowerSave = false;
        bool autoDimming = true;
        uint32_t sleepTimeout = 300000; // 5min

        // Pentest
        bool autoSaveCaptures = true;
        bool continuousMonitor = false;
        bool aggressiveScanning = false;
    };

    /**
     * @brief Estat√≠sticas de bateria
     */
    struct BatteryStats {
        uint8_t percentage;
        uint16_t voltage;          // mV
        int16_t current;           // mA
        bool charging;
        uint32_t estimatedRuntime; // minutos
        String status;
    };

private:
    Preferences prefs;
    Mode currentMode = NEKO_MODE;
    Profile currentProfile;

    // Estat√≠sticas
    uint32_t modeStartTime = 0;
    uint32_t screenOnTime = 0;
    uint32_t lastActivity = 0;

    /**
     * @brief Perfis pr√©-configurados
     */
    Profile getPresetProfile(Mode mode) {
        Profile profile;

        switch(mode) {
            case NEKO_MODE:
                // Modo completo com todas features
                profile.animations = true;
                profile.particles = true;
                profile.nekoReactions = true;
                profile.sounds = true;
                profile.music = true;
                profile.vibration = true;
                profile.brightness = 180;
                profile.displayFPS = 30;
                profile.verboseLogging = false;
                profile.minimalUI = false;
                break;

            case PROFESSIONAL:
                // Modo profissional clean
                profile.animations = false;
                profile.particles = false;
                profile.nekoReactions = false;
                profile.sounds = false;
                profile.music = false;
                profile.vibration = false;
                profile.beeps = true;
                profile.brightness = 150;
                profile.displayFPS = 20;
                profile.verboseLogging = true;
                profile.minimalUI = true;
                profile.statusIcons = true;
                break;

            case STEALTH:
                // Modo stealth - m√≠nimo feedback
                profile.animations = false;
                profile.particles = false;
                profile.nekoReactions = false;
                profile.sounds = false;
                profile.music = false;
                profile.vibration = false;
                profile.beeps = false;
                profile.ledIndicators = false;
                profile.brightness = 80;
                profile.displayFPS = 15;
                profile.verboseLogging = false;
                profile.minimalUI = true;
                profile.autoDimming = true;
                profile.screenTimeout = 30;
                break;

            case BATTERY_SAVER:
                // Economia m√°xima de bateria
                profile.animations = false;
                profile.particles = false;
                profile.nekoReactions = false;
                profile.sounds = false;
                profile.music = false;
                profile.vibration = false;
                profile.beeps = false;
                profile.brightness = 50;
                profile.displayFPS = 10;
                profile.cpuPowerSave = true;
                profile.wifiPowerSave = true;
                profile.autoDimming = true;
                profile.screenTimeout = 15;
                profile.sleepTimeout = 60000; // 1min
                profile.reducedAnimations = true;
                profile.minimalUI = true;
                break;

            case CUSTOM:
                // Mant√©m configura√ß√£o atual
                profile = currentProfile;
                break;
        }

        return profile;
    }

    /**
     * @brief Aplica perfil ao sistema
     */
    void applyProfile(const Profile& profile) {
        currentProfile = profile;

        // Aplica configura√ß√µes de display
        M5.Display.setBrightness(profile.brightness);

        // Aplica configura√ß√µes de CPU
        if (profile.cpuPowerSave) {
            setCpuFrequencyMhz(80); // Reduz para 80MHz
        } else {
            setCpuFrequencyMhz(240); // Full speed
        }

        // Aplica configura√ß√µes de WiFi
        if (profile.wifiPowerSave) {
            // esp_wifi_set_ps(WIFI_PS_MAX_MODEM);
            // TODO: Implementar power save WiFi
        }

        Serial.println("[OpsMode] ‚öôÔ∏è Perfil aplicado");
    }

    /**
     * @brief Salva perfil nas prefer√™ncias
     */
    void saveProfile() {
        prefs.putUChar("mode", currentMode);
        prefs.putBool("animations", currentProfile.animations);
        prefs.putBool("sounds", currentProfile.sounds);
        prefs.putUChar("brightness", currentProfile.brightness);
        prefs.putUChar("fps", currentProfile.displayFPS);
        // ... salvar outros par√¢metros conforme necess√°rio
    }

    /**
     * @brief Carrega perfil das prefer√™ncias
     */
    void loadProfile() {
        currentMode = (Mode)prefs.getUChar("mode", NEKO_MODE);
        currentProfile = getPresetProfile(currentMode);

        // Sobrescreve com valores customizados se existirem
        if (prefs.isKey("animations")) {
            currentProfile.animations = prefs.getBool("animations");
        }
        // ... carregar outros par√¢metros
    }

public:
    /**
     * @brief Inicializa gerenciador de modos
     */
    bool begin() {
        prefs.begin("opsmode", false);

        // Carrega modo salvo
        loadProfile();

        modeStartTime = millis();
        lastActivity = millis();

        Serial.println("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
        Serial.println("‚ïë     ‚öôÔ∏è  FIELD OPS MODE MANAGER        ‚ïë");
        Serial.println("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£");
        Serial.printf( "‚ïë  Current Mode: %-20s   ‚ïë\n", getModeString().c_str());
        Serial.printf( "‚ïë  Brightness: %-3d                     ‚ïë\n",
                      currentProfile.brightness);
        Serial.printf( "‚ïë  FPS: %-2d                             ‚ïë\n",
                      currentProfile.displayFPS);
        Serial.printf( "‚ïë  Animations: %-3s                     ‚ïë\n",
                      currentProfile.animations ? "ON" : "OFF");
        Serial.println("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");

        // Aplica perfil
        applyProfile(currentProfile);

        return true;
    }

    /**
     * @brief Alterna para um modo espec√≠fico
     */
    void setMode(Mode mode) {
        if (mode == currentMode) return;

        Serial.printf("[OpsMode] üîÑ Alternando: %s ‚Üí %s\n",
                     getModeString().c_str(),
                     getModeString(mode).c_str());

        currentMode = mode;
        Profile newProfile = getPresetProfile(mode);
        applyProfile(newProfile);
        saveProfile();

        modeStartTime = millis();
    }

    /**
     * @brief Alterna entre modos ciclicamente
     */
    void toggleMode() {
        Mode nextMode = (Mode)((currentMode + 1) % 4);
        setMode(nextMode);
    }

    /**
     * @brief Ativa modo NEKO completo
     */
    void enableNekoMode() {
        setMode(NEKO_MODE);
    }

    /**
     * @brief Ativa modo profissional
     */
    void enableProfessionalMode() {
        setMode(PROFESSIONAL);
    }

    /**
     * @brief Ativa modo stealth
     */
    void enableStealthMode() {
        setMode(STEALTH);
    }

    /**
     * @brief Ativa economia de bateria
     */
    void enableBatterySaver() {
        setMode(BATTERY_SAVER);
    }

    /**
     * @brief Registra atividade do usu√°rio
     */
    void userActivity() {
        lastActivity = millis();

        // Se tela estava apagada, reacende
        if (M5.Display.getBrightness() == 0) {
            M5.Display.setBrightness(currentProfile.brightness);
        }
    }

    /**
     * @brief Atualiza gerenciamento de energia (chame no loop)
     */
    void update() {
        uint32_t now = millis();
        uint32_t idleTime = now - lastActivity;

        // Auto-dimming
        if (currentProfile.autoDimming && currentProfile.screenTimeout > 0) {
            uint32_t timeout = currentProfile.screenTimeout * 1000;

            if (idleTime >= timeout) {
                // Desliga tela
                if (M5.Display.getBrightness() > 0) {
                    M5.Display.setBrightness(0);
                    Serial.println("[OpsMode] üí§ Tela desligada (timeout)");
                }
            }
        }

        // Auto-sleep
        if (currentProfile.sleepTimeout > 0 && idleTime >= currentProfile.sleepTimeout) {
            Serial.println("[OpsMode] üò¥ Entrando em sleep mode...");
            // TODO: Implementar deep sleep
        }
    }

    /**
     * @brief Obt√©m estat√≠sticas de bateria
     */
    BatteryStats getBatteryStats() {
        BatteryStats stats;

        // M5Stack Cardputer tem gerenciamento de bateria
        // TODO: Implementar leitura real da bateria via I2C/ADC

        stats.percentage = 85; // Placeholder
        stats.voltage = 3700;  // mV
        stats.current = -150;  // mA (negativo = descarga)
        stats.charging = false;
        stats.estimatedRuntime = 120; // minutos

        if (stats.charging) {
            stats.status = "Charging";
        } else if (stats.percentage > 80) {
            stats.status = "Good";
        } else if (stats.percentage > 20) {
            stats.status = "Normal";
        } else {
            stats.status = "Low";
        }

        return stats;
    }

    /**
     * @brief Imprime status de bateria
     */
    void printBatteryStatus() {
        BatteryStats bat = getBatteryStats();

        Serial.println("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
        Serial.println("‚ïë         üîã BATTERY STATUS             ‚ïë");
        Serial.println("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£");
        Serial.printf( "‚ïë  Level: %3d%%                          ‚ïë\n", bat.percentage);
        Serial.printf( "‚ïë  Voltage: %4d mV                     ‚ïë\n", bat.voltage);
        Serial.printf( "‚ïë  Current: %4d mA                     ‚ïë\n", bat.current);
        Serial.printf( "‚ïë  Status: %-28s ‚ïë\n", bat.status.c_str());
        Serial.printf( "‚ïë  Charging: %-3s                       ‚ïë\n",
                      bat.charging ? "YES" : "NO");
        Serial.printf( "‚ïë  Est. Runtime: ~%3lu min              ‚ïë\n",
                      bat.estimatedRuntime);
        Serial.println("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
    }

    /**
     * @brief Imprime configura√ß√£o atual
     */
    void printCurrentConfig() {
        Serial.println("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
        Serial.println("‚ïë      üìã CURRENT CONFIGURATION         ‚ïë");
        Serial.println("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£");
        Serial.printf( "‚ïë  Mode: %-30s ‚ïë\n", getModeString().c_str());
        Serial.println("‚ïü‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ï¢");
        Serial.printf( "‚ïë  Animations: %-3s   Particles: %-3s    ‚ïë\n",
                      currentProfile.animations ? "ON" : "OFF",
                      currentProfile.particles ? "ON" : "OFF");
        Serial.printf( "‚ïë  Sounds: %-3s       Music: %-3s        ‚ïë\n",
                      currentProfile.sounds ? "ON" : "OFF",
                      currentProfile.music ? "ON" : "OFF");
        Serial.printf( "‚ïë  Vibration: %-3s   LED: %-3s          ‚ïë\n",
                      currentProfile.vibration ? "ON" : "OFF",
                      currentProfile.ledIndicators ? "ON" : "OFF");
        Serial.printf( "‚ïë  Brightness: %-3d   FPS: %-2d          ‚ïë\n",
                      currentProfile.brightness, currentProfile.displayFPS);
        Serial.printf( "‚ïë  Screen Timeout: %-3ds                ‚ïë\n",
                      currentProfile.screenTimeout);
        Serial.println("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
    }

    /**
     * @brief Obt√©m string do modo
     */
    String getModeString(Mode mode) const {
        switch(mode) {
            case NEKO_MODE:       return "üê± Neko Mode";
            case PROFESSIONAL:    return "üíº Professional";
            case STEALTH:        return "ü•∑ Stealth";
            case BATTERY_SAVER:  return "üîã Battery Saver";
            case CUSTOM:         return "‚öôÔ∏è Custom";
            default:             return "‚ùì Unknown";
        }
    }

    String getModeString() const {
        return getModeString(currentMode);
    }

    // Getters para m√≥dulos consultarem configura√ß√£o
    const Profile& getProfile() const { return currentProfile; }
    Mode getMode() const { return currentMode; }

    bool isAnimationsEnabled() const { return currentProfile.animations; }
    bool isParticlesEnabled() const { return currentProfile.particles; }
    bool isNekoReactionsEnabled() const { return currentProfile.nekoReactions; }
    bool isSoundsEnabled() const { return currentProfile.sounds; }
    bool isMusicEnabled() const { return currentProfile.music; }
    bool isVibrationEnabled() const { return currentProfile.vibration; }
    bool isMinimalUI() const { return currentProfile.minimalUI; }
    uint8_t getDisplayFPS() const { return currentProfile.displayFPS; }
    uint8_t getBrightness() const { return currentProfile.brightness; }

    // Setters para configura√ß√£o customizada
    void setAnimations(bool enabled) {
        currentProfile.animations = enabled;
        saveProfile();
    }

    void setBrightness(uint8_t level) {
        currentProfile.brightness = level;
        M5.Display.setBrightness(level);
        saveProfile();
    }

    void setDisplayFPS(uint8_t fps) {
        currentProfile.displayFPS = fps;
        saveProfile();
    }
};

#endif // M5GOTCHI_FIELD_OPS_MODE_H
