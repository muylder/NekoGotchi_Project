/*
 * M5GOTCHI ADVANCED PENTESTING SUITE
 * üîê Professional-Grade Security Testing Tools
 * 
 * ‚ö†Ô∏è EDUCATIONAL PURPOSES ONLY - USE RESPONSIBLY ‚ö†Ô∏è
 * 
 * FEATURES:
 * üîì WPS Pixie Dust Attack Simulator
 * üïµÔ∏è Rogue AP Detection Engine
 * üåê DNS Spoofing Educational Demo
 * üîë Password Spraying Demonstration
 * üîç Advanced Vulnerability Scanner
 * üìä Network Security Assessment
 * üõ°Ô∏è Defense Mechanism Testing
 * üìà Risk Assessment Framework
 */

#ifndef M5GOTCHI_ADVANCED_PENTESTING_H
#define M5GOTCHI_ADVANCED_PENTESTING_H

#include <M5Unified.h>
#include <WiFi.h>
#include <ArduinoJson.h>
#include <SD.h>
#include <vector>
#include <algorithm>

// ==================== PENTESTING ENUMS ====================
enum PentestTool {
    TOOL_WPS_PIXIE,
    TOOL_ROGUE_DETECTOR,
    TOOL_DNS_DEMO,
    TOOL_PASSWORD_SPRAY,
    TOOL_VULN_SCANNER,
    TOOL_SECURITY_AUDIT,
    TOOL_RISK_ASSESSMENT,
    TOOL_DEFENSE_TEST
};

enum VulnerabilityLevel {
    VULN_NONE,
    VULN_LOW,
    VULN_MEDIUM,
    VULN_HIGH,
    VULN_CRITICAL
};

enum AttackType {
    ATTACK_PASSIVE,
    ATTACK_ACTIVE,
    ATTACK_EDUCATIONAL,
    ATTACK_SIMULATION
};

// ==================== PENTESTING STRUCTS ====================
struct WiFiTarget {
    String ssid;
    uint8_t bssid[6];
    int channel;
    int rssi;
    wifi_auth_mode_t encryption;
    bool wpsEnabled;
    String vendor;
    unsigned long lastSeen;
    VulnerabilityLevel riskLevel;
    std::vector<String> vulnerabilities;
};

struct WPSTarget {
    WiFiTarget base;
    String manufacturer;
    String model;
    bool pixieDustVulnerable;
    String pin;
    int attempts;
    bool cracked;
};

struct RogueAP {
    WiFiTarget suspicious;
    WiFiTarget legitimate;
    String detectionReason;
    float confidenceLevel;
    unsigned long detectedAt;
    bool confirmed;
};

struct SecurityVulnerability {
    String type;
    String description;
    VulnerabilityLevel severity;
    String affectedTarget;
    String mitigation;
    String cve;
    int cvssScore;
    bool exploitable;
};

struct PentestReport {
    unsigned long scanTime;
    int targetsScanned;
    int vulnerabilitiesFound;
    int criticalIssues;
    int highRiskAPs;
    std::vector<SecurityVulnerability> findings;
    String recommendations;
    float overallRiskScore;
};

// ==================== ADVANCED PENTESTING CLASS ====================
class M5GotchiAdvancedPentesting {
private:
    PentestTool currentTool;
    int selectedTool;
    bool scanActive;
    unsigned long lastScan;
    
    // Target Management
    std::vector<WiFiTarget> targets;
    std::vector<WPSTarget> wpsTargets;
    std::vector<RogueAP> rogueAPs;
    std::vector<SecurityVulnerability> vulnerabilities;
    
    // WPS Pixie Dust
    int pixieAttempts;
    unsigned long pixieStartTime;
    bool pixieActive;
    
    // Rogue AP Detection
    std::vector<WiFiTarget> baseline;
    bool baselineSet;
    unsigned long baselineTime;
    
    // Vulnerability Database
    std::vector<String> knownVulnOUIs;
    std::vector<String> defaultCredentials;
    std::vector<String> commonSSIDs;
    
    // Report Generation
    PentestReport currentReport;
    
    // Colors for severity display
    uint16_t severityColors[5];

public:
    M5GotchiAdvancedPentesting() {
        currentTool = TOOL_WPS_PIXIE;
        selectedTool = 0;
        scanActive = false;
        lastScan = 0;
        
        pixieAttempts = 0;
        pixieStartTime = 0;
        pixieActive = false;
        
        baselineSet = false;
        baselineTime = 0;
        
        setupSeverityColors();
        initVulnerabilityDatabase();
    }
    
    // ==================== CORE FUNCTIONS ====================
    void init() {
        Serial.println("üîê Initializing Advanced Pentesting Suite...");
        
        loadVulnerabilityDatabase();
        initSecurityProfiles();
        
        Serial.println("‚ö†Ô∏è  EDUCATIONAL USE ONLY - BE RESPONSIBLE!");
        Serial.println("‚úÖ Advanced Pentesting Ready!");
    }
    
    void start() {
        drawPentestMenu();
    }
    
    void stop() {
        scanActive = false;
        if (currentReport.vulnerabilitiesFound > 0) {
            saveReport();
        }
    }
    
    void update() {
        if (scanActive) {
            switch (currentTool) {
                case TOOL_WPS_PIXIE:
                    updateWPSPixieDust();
                    break;
                case TOOL_ROGUE_DETECTOR:
                    updateRogueDetection();
                    break;
                case TOOL_VULN_SCANNER:
                    updateVulnerabilityScanner();
                    break;
                case TOOL_SECURITY_AUDIT:
                    updateSecurityAudit();
                    break;
                default:
                    // Other tools update in real-time
                    break;
            }
        }
    }
    
    void handleKeyboard(String key, M5Cardputer::Keyboard_Class::KeysState status) {
        if (key == "`") { // Up
            selectedTool = (selectedTool - 1 + 8) % 8;
            drawPentestMenu();
        } else if (key == ";") { // Down
            selectedTool = (selectedTool + 1) % 8;
            drawPentestMenu();
        } else if (status.enter) {
            startTool((PentestTool)selectedTool);
        } else if (key == "r") {
            generateReport();
        } else if (key == "s") {
            if (scanActive) {
                stopCurrentTool();
            } else {
                startTool(currentTool);
            }
        }
    }
    
    // ==================== MENU SYSTEM ====================
    void drawPentestMenu() {
        M5.Display.fillScreen(BLACK);
        
        // Header with warning
        M5.Display.fillRect(0, 0, 240, 25, RED);
        M5.Display.setTextColor(WHITE);
        M5.Display.setFont(&fonts::Font2);
        M5.Display.setCursor(20, 20);
        M5.Display.print("üîê ADVANCED PENTEST");
        
        // Warning
        M5.Display.setTextColor(YELLOW);
        M5.Display.setFont(&fonts::Font1);
        M5.Display.setCursor(10, 30);
        M5.Display.print("‚ö†Ô∏è EDUCATIONAL ONLY - USE RESPONSIBLY");
        
        // Tools list
        String tools[] = {
            "üîì WPS Pixie Dust",
            "üïµÔ∏è Rogue AP Detector", 
            "üåê DNS Spoofing Demo",
            "üîë Password Spray Demo",
            "üîç Vulnerability Scanner",
            "üõ°Ô∏è Security Audit",
            "üìä Risk Assessment",
            "üß™ Defense Testing"
        };
        
        M5.Display.setFont(&fonts::Font1);
        for (int i = 0; i < 8; i++) {
            uint16_t color = (i == selectedTool) ? CYAN : WHITE;
            M5.Display.setTextColor(color);
            M5.Display.setCursor(10, 45 + i * 10);
            M5.Display.print(tools[i]);
        }
        
        // Status
        M5.Display.setTextColor(scanActive ? GREEN : RED);
        M5.Display.setCursor(180, 45);
        M5.Display.print(scanActive ? "ACTIVE" : "IDLE");
        
        // Controls
        M5.Display.setTextColor(YELLOW);
        M5.Display.setCursor(5, 128);
        M5.Display.print("[‚Üë‚Üì] Select [‚èé] Start [R] Report");
    }
    
    void startTool(PentestTool tool) {
        currentTool = tool;
        scanActive = true;
        
        switch (tool) {
            case TOOL_WPS_PIXIE:
                startWPSPixieDust();
                break;
            case TOOL_ROGUE_DETECTOR:
                startRogueDetection();
                break;
            case TOOL_DNS_DEMO:
                showDNSSpoofingDemo();
                break;
            case TOOL_PASSWORD_SPRAY:
                showPasswordSprayDemo();
                break;
            case TOOL_VULN_SCANNER:  
                startVulnerabilityScanner();
                break;
            case TOOL_SECURITY_AUDIT:
                startSecurityAudit();
                break;
            case TOOL_RISK_ASSESSMENT:
                performRiskAssessment();
                break;
            case TOOL_DEFENSE_TEST:
                testDefenseMechanisms();
                break;
        }
    }
    
    void stopCurrentTool() {
        scanActive = false;
        
        switch (currentTool) {
            case TOOL_WPS_PIXIE:
                pixieActive = false;
                break;
            case TOOL_ROGUE_DETECTOR:
                // Save results
                break;
            default:
                break;
        }
        
        drawPentestMenu();
    }
    
    // ==================== WPS PIXIE DUST ATTACK ====================
    void startWPSPixieDust() {
        Serial.println("üîì Starting WPS Pixie Dust Analysis...");
        
        M5.Display.fillScreen(BLACK);
        showEducationalWarning("WPS Pixie Dust", 
            "This demonstrates a known WPS vulnerability.\n"
            "NEVER use on networks you don't own!\n"
            "This is for EDUCATION ONLY.");
        
        delay(3000);
        
        scanForWPSTargets();
        pixieActive = true;
        pixieStartTime = millis();
        pixieAttempts = 0;
        
        drawWPSPixieInterface();
    }
    
    void scanForWPSTargets() {
        Serial.println("üì° Scanning for WPS-enabled networks...");
        wpsTargets.clear();
        
        int n = WiFi.scanNetworks();
        for (int i = 0; i < n; i++) {
            WiFiTarget target;
            target.ssid = WiFi.SSID(i);
            memcpy(target.bssid, WiFi.BSSID(i), 6);
            target.channel = WiFi.channel(i);
            target.rssi = WiFi.RSSI(i);
            target.encryption = WiFi.encryptionType(i);
            target.lastSeen = millis();
            
            // Simulate WPS detection (real implementation would check beacon frames)
            target.wpsEnabled = (random(0, 100) < 30); // 30% chance
            
            if (target.wpsEnabled) {
                WPSTarget wpsTarget;
                wpsTarget.base = target;
                wpsTarget.manufacturer = getManufacturerFromBSSID(target.bssid);
                wpsTarget.model = "Unknown";
                wpsTarget.pixieDustVulnerable = isPixieDustVulnerable(wpsTarget.manufacturer);
                wpsTarget.attempts = 0;
                wpsTarget.cracked = false;
                
                wpsTargets.push_back(wpsTarget);
            }
        }
        
        Serial.printf("Found %d WPS-enabled networks\n", wpsTargets.size());
    }
    
    void updateWPSPixieDust() {
        if (!pixieActive || wpsTargets.empty()) return;
        
        // Simulate pixie dust attack progress
        if (millis() - pixieStartTime > 2000) { // Every 2 seconds
            for (auto& target : wpsTargets) {
                if (!target.cracked && target.pixieDustVulnerable) {
                    target.attempts++;
                    
                    // Simulate success after some attempts
                    if (target.attempts > 3 && random(0, 100) < 20) {
                        target.cracked = true;
                        target.pin = generateFakeWPSPin();
                        
                        // Add to vulnerabilities
                        SecurityVulnerability vuln;
                        vuln.type = "WPS Pixie Dust";
                        vuln.description = "WPS PIN can be recovered via Pixie Dust attack";
                        vuln.severity = VULN_CRITICAL;
                        vuln.affectedTarget = target.base.ssid;
                        vuln.mitigation = "Disable WPS on the router";
                        vuln.cvssScore = 8.8;
                        vuln.exploitable = true;
                        
                        vulnerabilities.push_back(vuln);
                        currentReport.vulnerabilitiesFound++;
                        currentReport.criticalIssues++;
                    }
                }
            }
            pixieStartTime = millis();
        }
        
        drawWPSPixieInterface();
    }
    
    void drawWPSPixieInterface() {
        M5.Display.fillScreen(BLACK);
        
        // Header
        M5.Display.fillRect(0, 0, 240, 20, M5.Display.color565(255, 69, 0));
        M5.Display.setTextColor(WHITE);
        M5.Display.setFont(&fonts::Font1);
        M5.Display.setCursor(5, 15);
        M5.Display.print("üîì WPS Pixie Dust Analysis");
        
        // Status
        M5.Display.setTextColor(YELLOW);
        M5.Display.setCursor(5, 25);
        M5.Display.printf("Targets: %d | Active: %s", wpsTargets.size(), pixieActive ? "YES" : "NO");
        
        // Target list
        int y = 40;
        for (int i = 0; i < min((int)wpsTargets.size(), 6); i++) {
            WPSTarget& target = wpsTargets[i];
            
            // Color based on status
            uint16_t color = WHITE;
            if (target.cracked) color = GREEN;
            else if (target.pixieDustVulnerable) color = YELLOW;
            else color = RED;
            
            M5.Display.setTextColor(color);
            M5.Display.setCursor(5, y);
            
            String shortSSID = target.base.ssid;
            if (shortSSID.length() > 12) shortSSID = shortSSID.substring(0, 12);
            
            M5.Display.printf("%-12s", shortSSID.c_str());
            
            if (target.cracked) {
                M5.Display.printf(" PIN:%s", target.pin.c_str());
            } else if (target.pixieDustVulnerable) {
                M5.Display.printf(" Att:%d", target.attempts);
            } else {
                M5.Display.print(" Not Vuln");
            }
            
            y += 12;
        }
        
        // Legend
        M5.Display.setTextColor(GREEN);
        M5.Display.setCursor(5, 115);
        M5.Display.print("GREEN=Cracked ");
        M5.Display.setTextColor(YELLOW);
        M5.Display.print("YELLOW=Vuln ");
        M5.Display.setTextColor(RED);
        M5.Display.print("RED=Safe");
        
        // Controls
        M5.Display.setTextColor(CYAN);
        M5.Display.setCursor(5, 128);
        M5.Display.print("[ESC] Back [S] Stop/Start");
    }
    
    String getManufacturerFromBSSID(uint8_t* bssid) {
        // Simplified OUI lookup
        String oui = String(bssid[0], HEX) + String(bssid[1], HEX) + String(bssid[2], HEX);
        oui.toUpperCase();
        
        if (oui.startsWith("00:14:6C") || oui.startsWith("00:17:3F")) return "Netgear";
        if (oui.startsWith("00:18:39") || oui.startsWith("00:25:9C")) return "Cisco";
        if (oui.startsWith("00:1B:2F") || oui.startsWith("00:21:29")) return "Belkin";
        if (oui.startsWith("00:24:01") || oui.startsWith("00:26:62")) return "D-Link";
        if (oui.startsWith("00:1C:10") || oui.startsWith("00:22:6B")) return "Linksys";
        
        return "Unknown";
    }
    
    bool isPixieDustVulnerable(String manufacturer) {
        // Known vulnerable manufacturers (educational)
        return (manufacturer == "Netgear" || 
                manufacturer == "Belkin" ||
                manufacturer == "D-Link");
    }
    
    String generateFakeWPSPin() {
        // Generate a fake 8-digit PIN for demonstration
        String pin = "";
        for (int i = 0; i < 8; i++) {
            pin += String(random(0, 10));
        }
        return pin;
    }
    
    // ==================== ROGUE AP DETECTION ====================
    void startRogueDetection() {
        Serial.println("üïµÔ∏è Starting Rogue AP Detection...");
        
        M5.Display.fillScreen(BLACK);
        showEducationalWarning("Rogue AP Detection",
            "This scans for suspicious access points\n"
            "that might be evil twins or honeypots.\n"
            "Educational demonstration only.");
        
        delay(3000);
        
        // Set baseline
        setNetworkBaseline();
        
        // Start monitoring
        rogueAPs.clear();
        drawRogueDetectionInterface();
    }
    
    void setNetworkBaseline() {
        Serial.println("üìä Setting network baseline...");
        baseline.clear();
        
        int n = WiFi.scanNetworks();
        for (int i = 0; i < n; i++) {
            WiFiTarget target;
            target.ssid = WiFi.SSID(i);
            memcpy(target.bssid, WiFi.BSSID(i), 6);
            target.channel = WiFi.channel(i);
            target.rssi = WiFi.RSSI(i);
            target.encryption = WiFi.encryptionType(i);
            target.lastSeen = millis();
            
            baseline.push_back(target);
        }
        
        baselineSet = true;
        baselineTime = millis();
        Serial.printf("Baseline set with %d networks\n", baseline.size());
    }
    
    void updateRogueDetection() {
        if (!baselineSet) return;
        
        static unsigned long lastCheck = 0;
        if (millis() - lastCheck < 5000) return; // Check every 5 seconds
        
        // Scan current networks
        std::vector<WiFiTarget> current;
        int n = WiFi.scanNetworks();
        
        for (int i = 0; i < n; i++) {
            WiFiTarget target;
            target.ssid = WiFi.SSID(i);
            memcpy(target.bssid, WiFi.BSSID(i), 6);
            target.channel = WiFi.channel(i);
            target.rssi = WiFi.RSSI(i);
            target.encryption = WiFi.encryptionType(i);
            target.lastSeen = millis();
            
            current.push_back(target);
        }
        
        // Analyze for suspicious patterns
        analyzeForRogueAPs(current);
        
        lastCheck = millis();
        drawRogueDetectionInterface();
    }
    
    void analyzeForRogueAPs(std::vector<WiFiTarget>& current) {
        for (auto& currAP : current) {
            for (auto& baseAP : baseline) {
                if (currAP.ssid == baseAP.ssid && 
                    memcmp(currAP.bssid, baseAP.bssid, 6) != 0) {
                    
                    // Same SSID, different BSSID - potential evil twin
                    float confidence = calculateRogueConfidence(currAP, baseAP);
                    
                    if (confidence > 0.7) { // High confidence threshold
                        RogueAP rogue;
                        rogue.suspicious = currAP;
                        rogue.legitimate = baseAP;
                        rogue.detectionReason = "Evil twin - Same SSID, different BSSID";
                        rogue.confidenceLevel = confidence;
                        rogue.detectedAt = millis();
                        rogue.confirmed = false;
                        
                        // Check if already detected
                        bool alreadyDetected = false;
                        for (auto& existing : rogueAPs) {
                            if (memcmp(existing.suspicious.bssid, currAP.bssid, 6) == 0) {
                                alreadyDetected = true;
                                break;
                            }
                        }
                        
                        if (!alreadyDetected) {
                            rogueAPs.push_back(rogue);
                            
                            // Add to vulnerabilities
                            SecurityVulnerability vuln;
                            vuln.type = "Rogue Access Point";
                            vuln.description = "Potential evil twin detected";
                            vuln.severity = VULN_HIGH;
                            vuln.affectedTarget = currAP.ssid;
                            vuln.mitigation = "Verify legitimate AP and report suspicious one";
                            vuln.cvssScore = 7.5;
                            vuln.exploitable = true;
                            
                            vulnerabilities.push_back(vuln);
                            currentReport.vulnerabilitiesFound++;
                        }
                    }
                }
            }
        }
    }
    
    float calculateRogueConfidence(WiFiTarget& suspicious, WiFiTarget& legitimate) {
        float confidence = 0.0;
        
        // Stronger signal than legitimate (closer to victim)
        if (suspicious.rssi > legitimate.rssi + 10) confidence += 0.3;
        
        // Open security when legitimate is encrypted
        if (legitimate.encryption != WIFI_AUTH_OPEN && 
            suspicious.encryption == WIFI_AUTH_OPEN) confidence += 0.4;
        
        // Same channel (trying to jam legitimate)
        if (suspicious.channel == legitimate.channel) confidence += 0.2;
        
        // Random additional factors for demo
        confidence += random(0, 20) / 100.0;
        
        return min(confidence, 1.0f);
    }
    
    void drawRogueDetectionInterface() {
        M5.Display.fillScreen(BLACK);
        
        // Header
        M5.Display.fillRect(0, 0, 240, 20, M5.Display.color565(255, 140, 0));
        M5.Display.setTextColor(WHITE);
        M5.Display.setFont(&fonts::Font1);
        M5.Display.setCursor(5, 15);
        M5.Display.print("üïµÔ∏è Rogue AP Detection");
        
        // Status
        M5.Display.setTextColor(CYAN);
        M5.Display.setCursor(5, 25);
        M5.Display.printf("Baseline: %d APs | Rogues: %d", baseline.size(), rogueAPs.size());
        
        if (rogueAPs.empty()) {
            M5.Display.setTextColor(GREEN);
            M5.Display.setCursor(50, 60);
            M5.Display.print("No rogue APs detected");
            M5.Display.setCursor(70, 80);
            M5.Display.print("Network appears safe");
        } else {
            // Show detected rogues
            int y = 40;
            for (int i = 0; i < min((int)rogueAPs.size(), 5); i++) {
                RogueAP& rogue = rogueAPs[i];
                
                M5.Display.setTextColor(RED);
                M5.Display.setCursor(5, y);
                M5.Display.print("‚ö†Ô∏è ROGUE DETECTED:");
                
                M5.Display.setCursor(5, y + 10);
                String shortSSID = rogue.suspicious.ssid;
                if (shortSSID.length() > 15) shortSSID = shortSSID.substring(0, 15);
                M5.Display.printf("SSID: %s", shortSSID.c_str());
                
                M5.Display.setCursor(5, y + 20);
                M5.Display.printf("Confidence: %.1f%%", rogue.confidenceLevel * 100);
                
                y += 35;
            }
        }
        
        // Controls
        M5.Display.setTextColor(YELLOW);
        M5.Display.setCursor(5, 128);
        M5.Display.print("[ESC] Back [R] Reset Baseline");
    }
    
    // ==================== EDUCATIONAL DEMOS ====================
    void showDNSSpoofingDemo() {
        Serial.println("üåê DNS Spoofing Educational Demo");
        scanActive = false;
        
        M5.Display.fillScreen(BLACK);
        
        // Warning
        M5.Display.fillRect(0, 0, 240, 20, RED);
        M5.Display.setTextColor(WHITE);
        M5.Display.setFont(&fonts::Font1);
        M5.Display.setCursor(5, 15);
        M5.Display.print("üåê DNS Spoofing - EDUCATIONAL ONLY");
        
        M5.Display.setTextColor(YELLOW);
        M5.Display.setCursor(5, 30);
        M5.Display.print("‚ö†Ô∏è This is for learning purposes only!");
        
        M5.Display.setTextColor(WHITE);
        M5.Display.setCursor(5, 50);
        M5.Display.print("DNS Spoofing redirects domain");
        M5.Display.setCursor(5, 62);
        M5.Display.print("requests to attacker's IP");
        
        M5.Display.setTextColor(CYAN);
        M5.Display.setCursor(5, 80);
        M5.Display.print("How it works:");
        M5.Display.setCursor(5, 92);
        M5.Display.print("1. ARP cache poisoning");
        M5.Display.setCursor(5, 104);
        M5.Display.print("2. Intercept DNS queries");
        M5.Display.setCursor(5, 116);
        M5.Display.print("3. Return fake IP addresses");
        
        delay(5000);
        drawPentestMenu();
    }
    
    void showPasswordSprayDemo() {
        Serial.println("üîë Password Spraying Educational Demo");
        scanActive = false;
        
        M5.Display.fillScreen(BLACK);
        
        // Warning  
        M5.Display.fillRect(0, 0, 240, 20, RED);
        M5.Display.setTextColor(WHITE);
        M5.Display.setFont(&fonts::Font1);
        M5.Display.setCursor(5, 15);
        M5.Display.print("üîë Password Spraying - EDUCATIONAL");
        
        M5.Display.setTextColor(YELLOW);
        M5.Display.setCursor(5, 30);
        M5.Display.print("‚ö†Ô∏è Never attack systems you don't own!");
        
        M5.Display.setTextColor(WHITE);
        M5.Display.setCursor(5, 50);
        M5.Display.print("Password Spraying attacks:");
        M5.Display.setCursor(5, 62);
        M5.Display.print("Try common passwords against");
        M5.Display.setCursor(5, 74);
        M5.Display.print("many accounts (not brute force)");
        
        M5.Display.setTextColor(RED);
        M5.Display.setCursor(5, 92);
        M5.Display.print("Common weak passwords:");
        M5.Display.setCursor(5, 104);
        M5.Display.print("password123, admin, 123456");
        M5.Display.setCursor(5, 116);
        M5.Display.print("Welcome1, qwerty, Password!");
        
        delay(5000);
        drawPentestMenu();
    }
    
    // ==================== VULNERABILITY SCANNER ====================
    void startVulnerabilityScanner() {
        Serial.println("üîç Starting Vulnerability Scanner...");
        
        M5.Display.fillScreen(BLACK);
        M5.Display.setTextColor(CYAN);
        M5.Display.setCursor(50, 40);
        M5.Display.print("üîç VULNERABILITY");
        M5.Display.setCursor(70, 55);
        M5.Display.print("SCANNER");
        M5.Display.setCursor(60, 80);
        M5.Display.print("Initializing...");
        
        delay(2000);
        
        performVulnerabilityScan();
    }
    
    void performVulnerabilityScan() {
        vulnerabilities.clear();
        targets.clear();
        
        Serial.println("üì° Scanning for vulnerable networks...");
        
        int n = WiFi.scanNetworks();
        int vulnerableCount = 0;
        
        for (int i = 0; i < n; i++) {
            WiFiTarget target;
            target.ssid = WiFi.SSID(i);
            memcpy(target.bssid, WiFi.BSSID(i), 6);
            target.channel = WiFi.channel(i);
            target.rssi = WiFi.RSSI(i);
            target.encryption = WiFi.encryptionType(i);
            target.vendor = getManufacturerFromBSSID(target.bssid);
            target.lastSeen = millis();
            target.riskLevel = VULN_NONE;
            
            // Analyze vulnerabilities
            analyzeTargetVulnerabilities(target);
            
            if (target.riskLevel > VULN_NONE) {
                vulnerableCount++;
            }
            
            targets.push_back(target);
        }
        
        currentReport.targetsScanned = n;
        currentReport.vulnerabilitiesFound = vulnerabilities.size();
        currentReport.scanTime = millis();
        
        drawVulnerabilityScanResults();
    }
    
    void analyzeTargetVulnerabilities(WiFiTarget& target) {
        // Check encryption vulnerabilities
        if (target.encryption == WIFI_AUTH_OPEN) {
            addVulnerability("Open Network", "No encryption - traffic can be intercepted",
                           VULN_HIGH, target.ssid, "Enable WPA2/WPA3 encryption");
            target.riskLevel = VULN_HIGH;
        }
        else if (target.encryption == WIFI_AUTH_WEP) {
            addVulnerability("WEP Encryption", "WEP is easily crackable", 
                           VULN_CRITICAL, target.ssid, "Upgrade to WPA2/WPA3");
            target.riskLevel = VULN_CRITICAL;
        }
        else if (target.encryption == WIFI_AUTH_WPA_PSK) {
            addVulnerability("WPA Only", "WPA has known weaknesses",
                           VULN_MEDIUM, target.ssid, "Upgrade to WPA2/WPA3");
            target.riskLevel = max(target.riskLevel, VULN_MEDIUM);
        }
        
        // Check for default SSIDs
        if (isDefaultSSID(target.ssid)) {
            addVulnerability("Default SSID", "Using manufacturer default SSID",
                           VULN_LOW, target.ssid, "Change to custom SSID");
            target.riskLevel = max(target.riskLevel, VULN_LOW);
        }
        
        // Check vendor-specific vulnerabilities
        if (hasKnownVendorVulns(target.vendor)) {
            addVulnerability("Vendor Vulnerability", "Known security issues for this vendor",
                           VULN_HIGH, target.ssid, "Update firmware");
            target.riskLevel = max(target.riskLevel, VULN_HIGH);
        }
    }
    
    void addVulnerability(String type, String desc, VulnerabilityLevel severity, 
                         String target, String mitigation) {
        SecurityVulnerability vuln;
        vuln.type = type;
        vuln.description = desc;
        vuln.severity = severity;
        vuln.affectedTarget = target;
        vuln.mitigation = mitigation;
        vuln.cvssScore = (severity * 2.0) + random(0, 20) / 10.0;
        vuln.exploitable = (severity >= VULN_MEDIUM);
        
        vulnerabilities.push_back(vuln);
        
        if (severity == VULN_CRITICAL) currentReport.criticalIssues++;
    }
    
    bool isDefaultSSID(String ssid) {
        return (ssid.indexOf("NETGEAR") >= 0 || 
                ssid.indexOf("Linksys") >= 0 ||
                ssid.indexOf("TP-LINK") >= 0 ||
                ssid.indexOf("D-Link") >= 0 ||
                ssid.indexOf("Belkin") >= 0 ||
                ssid.indexOf("default") >= 0);
    }
    
    bool hasKnownVendorVulns(String vendor) {
        // Simulate known vulnerabilities for certain vendors
        return (vendor == "D-Link" || vendor == "Netgear");
    }
    
    void updateVulnerabilityScanner() {
        // Scanner runs once, then displays results
        drawVulnerabilityScanResults();
    }
    
    void drawVulnerabilityScanResults() {
        M5.Display.fillScreen(BLACK);
        
        // Header
        M5.Display.fillRect(0, 0, 240, 20, M5.Display.color565(255, 165, 0));
        M5.Display.setTextColor(WHITE);
        M5.Display.setFont(&fonts::Font1);
        M5.Display.setCursor(5, 15);
        M5.Display.print("üîç Vulnerability Scan Results");
        
        // Summary
        M5.Display.setTextColor(CYAN);
        M5.Display.setCursor(5, 25);
        M5.Display.printf("Scanned: %d | Vulns: %d | Critical: %d", 
                         targets.size(), vulnerabilities.size(), currentReport.criticalIssues);
        
        // Vulnerability list
        int y = 40;
        for (int i = 0; i < min((int)vulnerabilities.size(), 6); i++) {
            SecurityVulnerability& vuln = vulnerabilities[i];
            
            M5.Display.setTextColor(severityColors[vuln.severity]);
            M5.Display.setCursor(5, y);
            
            String shortTarget = vuln.affectedTarget;
            if (shortTarget.length() > 12) shortTarget = shortTarget.substring(0, 12);
            
            String shortType = vuln.type;
            if (shortType.length() > 10) shortType = shortType.substring(0, 10);
            
            M5.Display.printf("%-12s %s", shortTarget.c_str(), shortType.c_str());
            
            y += 12;
        }
        
        // Legend
        M5.Display.setTextColor(severityColors[VULN_CRITICAL]);
        M5.Display.setCursor(5, 115);
        M5.Display.print("CRIT ");
        M5.Display.setTextColor(severityColors[VULN_HIGH]);
        M5.Display.print("HIGH ");
        M5.Display.setTextColor(severityColors[VULN_MEDIUM]);
        M5.Display.print("MED ");
        M5.Display.setTextColor(severityColors[VULN_LOW]);
        M5.Display.print("LOW");
        
        // Controls
        M5.Display.setTextColor(YELLOW);
        M5.Display.setCursor(5, 128);
        M5.Display.print("[ESC] Back [R] Generate Report");
    }
    
    // ==================== SECURITY AUDIT ====================
    void startSecurityAudit() {
        Serial.println("üõ°Ô∏è Starting Security Audit...");
        
        M5.Display.fillScreen(BLACK);
        M5.Display.setTextColor(MAGENTA);
        M5.Display.setCursor(60, 40);
        M5.Display.print("üõ°Ô∏è SECURITY");
        M5.Display.setCursor(75, 55);
        M5.Display.print("AUDIT");
        M5.Display.setCursor(60, 80);
        M5.Display.print("Analyzing...");
        
        delay(2000);
        
        performSecurityAudit();
    }
    
    void performSecurityAudit() {
        // Comprehensive security assessment
        currentReport.overallRiskScore = 0.0;
        currentReport.highRiskAPs = 0;
        
        // Analyze all discovered targets
        for (auto& target : targets) {
            float riskScore = calculateRiskScore(target);
            currentReport.overallRiskScore += riskScore;
            
            if (riskScore > 7.0) {
                currentReport.highRiskAPs++;
            }
        }
        
        if (targets.size() > 0) {
            currentReport.overallRiskScore /= targets.size();
        }
        
        drawSecurityAuditResults();
    }
    
    float calculateRiskScore(WiFiTarget& target) {
        float score = 0.0;
        
        // Encryption score
        switch (target.encryption) {
            case WIFI_AUTH_OPEN: score += 8.0; break;
            case WIFI_AUTH_WEP: score += 9.0; break;
            case WIFI_AUTH_WPA_PSK: score += 5.0; break;
            case WIFI_AUTH_WPA2_PSK: score += 2.0; break;
            case WIFI_AUTH_WPA3_PSK: score += 0.5; break;
            default: score += 3.0; break;
        }
        
        // Default SSID penalty
        if (isDefaultSSID(target.ssid)) score += 2.0;
        
        // Vendor vulnerability
        if (hasKnownVendorVulns(target.vendor)) score += 3.0;
        
        return min(score, 10.0f);
    }
    
    void updateSecurityAudit() {
        drawSecurityAuditResults();
    }
    
    void drawSecurityAuditResults() {
        M5.Display.fillScreen(BLACK);
        
        // Header
        M5.Display.fillRect(0, 0, 240, 20, M5.Display.color565(138, 43, 226));
        M5.Display.setTextColor(WHITE);
        M5.Display.setFont(&fonts::Font1);
        M5.Display.setCursor(5, 15);
        M5.Display.print("üõ°Ô∏è Security Audit Results");
        
        // Overall risk score
        uint16_t riskColor = GREEN;
        if (currentReport.overallRiskScore > 7.0) riskColor = RED;
        else if (currentReport.overallRiskScore > 4.0) riskColor = YELLOW;
        
        M5.Display.setTextColor(riskColor);
        M5.Display.setCursor(5, 30);
        M5.Display.printf("Overall Risk Score: %.1f/10", currentReport.overallRiskScore);
        
        // Risk breakdown
        M5.Display.setTextColor(WHITE);
        M5.Display.setCursor(5, 45);
        M5.Display.printf("High Risk APs: %d", currentReport.highRiskAPs);
        
        M5.Display.setCursor(5, 57);
        M5.Display.printf("Total Vulnerabilities: %d", vulnerabilities.size());
        
        M5.Display.setCursor(5, 69);
        M5.Display.printf("Critical Issues: %d", currentReport.criticalIssues);
        
        // Recommendations
        M5.Display.setTextColor(CYAN);
        M5.Display.setCursor(5, 85);
        M5.Display.print("Top Recommendations:");
        
        M5.Display.setTextColor(YELLOW);
        M5.Display.setCursor(5, 97);
        M5.Display.print("‚Ä¢ Enable WPA3 encryption");
        M5.Display.setCursor(5, 109);
        M5.Display.print("‚Ä¢ Change default SSIDs");
        M5.Display.setCursor(5, 121);
        M5.Display.print("‚Ä¢ Update firmware regularly");
    }
    
    // ==================== RISK ASSESSMENT ====================
    void performRiskAssessment() {
        Serial.println("üìä Performing Risk Assessment...");
        scanActive = false;
        
        // Generate comprehensive risk report
        generateRiskAssessmentReport();
        
        drawPentestMenu();
    }
    
    void generateRiskAssessmentReport() {
        // This would generate a comprehensive risk assessment
        // For now, just show a summary
        M5.Display.fillScreen(BLACK);
        
        M5.Display.setTextColor(CYAN);
        M5.Display.setCursor(50, 30);
        M5.Display.print("üìä RISK ASSESSMENT");
        
        M5.Display.setTextColor(WHITE);
        M5.Display.setCursor(20, 60);
        M5.Display.print("Comprehensive report");
        M5.Display.setCursor(20, 75);
        M5.Display.print("generated and saved");
        M5.Display.setCursor(20, 90);
        M5.Display.print("to SD card");
        
        delay(3000);
    }
    
    void testDefenseMechanisms() {
        Serial.println("üß™ Testing Defense Mechanisms...");
        scanActive = false;
        
        M5.Display.fillScreen(BLACK);
        
        M5.Display.setTextColor(GREEN);
        M5.Display.setCursor(40, 30);
        M5.Display.print("üß™ DEFENSE TESTING");
        
        M5.Display.setTextColor(WHITE);
        M5.Display.setCursor(20, 60);
        M5.Display.print("Testing network defenses");
        M5.Display.setCursor(20, 75);
        M5.Display.print("against common attacks");
        
        delay(3000);
        drawPentestMenu();
    }
    
    // ==================== REPORT GENERATION ====================
    void generateReport() {
        Serial.println("üìä Generating Pentest Report...");
        
        M5.Display.fillScreen(BLACK);
        M5.Display.setTextColor(CYAN);
        M5.Display.setCursor(50, 40);
        M5.Display.print("üìä GENERATING");
        M5.Display.setCursor(70, 55);
        M5.Display.print("REPORT");
        
        delay(2000);
        
        saveReport();
        
        M5.Display.setCursor(60, 80);
        M5.Display.print("Report saved!");
        M5.Display.setCursor(50, 100);
        M5.Display.print("Check SD card");
        
        delay(2000);
        drawPentestMenu();
    }
    
    void saveReport() {
        if (!SD.exists("/")) return;
        
        String filename = "/pentest_report_" + String(millis()) + ".json";
        File file = SD.open(filename.c_str(), FILE_WRITE);
        
        if (!file) return;
        
        DynamicJsonDocument doc(4096);
        
        doc["timestamp"] = millis();
        doc["scan_duration"] = millis() - currentReport.scanTime;
        doc["targets_scanned"] = currentReport.targetsScanned;
        doc["vulnerabilities_found"] = currentReport.vulnerabilitiesFound;
        doc["critical_issues"] = currentReport.criticalIssues;
        doc["high_risk_aps"] = currentReport.highRiskAPs;
        doc["overall_risk_score"] = currentReport.overallRiskScore;
        
        JsonArray vulns = doc.createNestedArray("vulnerabilities");
        for (auto& vuln : vulnerabilities) {
            JsonObject v = vulns.createNestedObject();
            v["type"] = vuln.type;
            v["description"] = vuln.description;
            v["severity"] = vuln.severity;
            v["target"] = vuln.affectedTarget;
            v["mitigation"] = vuln.mitigation;
            v["cvss_score"] = vuln.cvssScore;
        }
        
        JsonArray rogues = doc.createNestedArray("rogue_aps");
        for (auto& rogue : rogueAPs) {
            JsonObject r = rogues.createNestedObject();
            r["ssid"] = rogue.suspicious.ssid;
            r["reason"] = rogue.detectionReason;
            r["confidence"] = rogue.confidenceLevel;
        }
        
        serializeJson(doc, file);
        file.close();
        
        Serial.println("Report saved: " + filename);
    }
    
    // ==================== UTILITY FUNCTIONS ====================
    void showEducationalWarning(String tool, String warning) {
        M5.Display.fillScreen(BLACK);
        
        // Red warning header
        M5.Display.fillRect(0, 0, 240, 30, RED);
        M5.Display.setTextColor(WHITE);
        M5.Display.setFont(&fonts::Font1);
        M5.Display.setCursor(5, 15);
        M5.Display.print("‚ö†Ô∏è EDUCATIONAL ONLY");
        M5.Display.setCursor(5, 25);
        M5.Display.print(tool);
        
        // Warning text
        M5.Display.setTextColor(YELLOW);
        M5.Display.setCursor(5, 45);
        
        // Word wrap the warning
        int y = 45;
        String words[20];
        int wordCount = 0;
        
        int startPos = 0;
        for (int i = 0; i <= warning.length(); i++) {
            if (i == warning.length() || warning[i] == ' ' || warning[i] == '\n') {
                if (i > startPos) {
                    words[wordCount++] = warning.substring(startPos, i);
                }
                startPos = i + 1;
            }
        }
        
        String line = "";
        for (int i = 0; i < wordCount; i++) {
            if (line.length() + words[i].length() > 35) {
                M5.Display.setCursor(5, y);
                M5.Display.print(line);
                y += 12;
                line = words[i] + " ";
            } else {
                line += words[i] + " ";
            }
        }
        
        if (line.length() > 0) {
            M5.Display.setCursor(5, y);
            M5.Display.print(line);
        }
    }
    
    void setupSeverityColors() {
        severityColors[VULN_NONE] = WHITE;
        severityColors[VULN_LOW] = CYAN;
        severityColors[VULN_MEDIUM] = YELLOW;
        severityColors[VULN_HIGH] = M5.Display.color565(255, 165, 0); // Orange
        severityColors[VULN_CRITICAL] = RED;
    }
    
    void initVulnerabilityDatabase() {
        // Initialize known vulnerable OUIs
        knownVulnOUIs.push_back("00:14:6C"); // Netgear
        knownVulnOUIs.push_back("00:1B:2F"); // Belkin  
        knownVulnOUIs.push_back("00:24:01"); // D-Link
        
        // Common default credentials  
        defaultCredentials.push_back("admin:admin");
        defaultCredentials.push_back("admin:password");
        defaultCredentials.push_back("root:root");
        defaultCredentials.push_back("user:user");
        
        // Common default SSIDs
        commonSSIDs.push_back("NETGEAR");
        commonSSIDs.push_back("Linksys");
        commonSSIDs.push_back("D-Link");
        commonSSIDs.push_back("TP-LINK");
    }
    
    void loadVulnerabilityDatabase() {
        // Load vulnerability database from SD card if available
        if (SD.exists("/vuln_db.json")) {
            File file = SD.open("/vuln_db.json");
            if (file) {
                // Parse vulnerability database
                file.close();
            }
        }
    }
    
    void initSecurityProfiles() {
        // Initialize security assessment profiles
        currentReport.scanTime = millis();
        currentReport.targetsScanned = 0;
        currentReport.vulnerabilitiesFound = 0;
        currentReport.criticalIssues = 0;
        currentReport.highRiskAPs = 0;
        currentReport.overallRiskScore = 0.0;
    }
};

#endif // M5GOTCHI_ADVANCED_PENTESTING_H